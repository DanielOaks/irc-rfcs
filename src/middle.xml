<!-- This document was prepared using Pandoc2rfc, https://github.com/miekg/pandoc2rfc -->

  
<section title="Introduction" anchor="introduction">
  
  <t>
    The Internet Relay Chat (IRC) protocol has been designed and
    implemented over a number of years, with multitudes of
    implementations and use cases appearing. This document describes
    version 3 of the IRC protocol.
  </t>
  <t>
    IRC is a text-based teleconferencing system, which has proven itself
    as a very valuable and useful protocol. It is well-suited to running
    on many machines in a distributed fashion. A typical setup involves
    multiple servers connected in a distributed network, through which
    messages are delivered and state is maintained across the network
    for the connected clients and active channels.
  </t>
  <t>
    The key words "MUST", "MUST NOT",
    "REQUIRED", "SHALL", "SHALL NOT",
    "SHOULD", "SHOULD NOT", "RECOMMENDED",
    "MAY", and "OPTIONAL" in this document are to be
    interpreted as described in <xref target="RFC2119"/>.
  </t>
  <section title="Servers" anchor="servers">
    
    <t>
      Servers form the backbone of IRC, providing a point to which
      clients may connect and talk to each other, and a point for other
      servers to connect to, forming an IRC network.
    </t>
    <t>
      The most common network configuration for IRC servers is that of a
      spanning tree [see <xref target="fig:typicalnet"/>], where
      each server acts as a central node for the rest of the net it
      sees.
    </t>
    <figure anchor="fig:typicalnet" align="center" title="Format of a typical IRC network."><artwork align="center">
                           [ Server 15 ]  [ Server 13 ] [ Server 14]
                                 /                \         /
                                /                  \       /
        [ Server 11 ] ------ [ Server 1 ]       [ Server 12]
                              /        \          /
                             /          \        /
                  [ Server 2 ]          [ Server 3 ]
                    /       \                      \
                   /         \                      \
           [ Server 4 ]    [ Server 5 ]         [ Server 6 ]
            /    |    \                           /
           /     |     \                         /
          /      |      \____                   /
         /       |           \                 /
 [ Server 7 ] [ Server 8 ] [ Server 9 ]   [ Server 10 ]

                                  :
                               [ etc. ]
                                  :
</artwork></figure>
    <t>
      
    </t>
  </section>
  <section title="Clients" anchor="clients">
    
    <t>
      A client is anything connecting to a server that is not another
      server. Each client is distinguished from other clients by a
      unique nickname. See the protocol grammar rules for what may and
      may not be used in a nickname. In addition to the nickname, all
      servers must have the following information about all clients: The
      real name of the host that the client is running on, the username
      of the client on that host, and the server to which the client is
      connected.
    </t>
    <section title="Operators" anchor="operators">
      
      <t>
        To allow a reasonable amount of order to be kept within the IRC
        network, a special class of clients (operators) are allowed to
        perform general maintenance functions on the network. Although
        the powers granted to an operator can be considered as
        'dangerous', they are nonetheless required.
      </t>
      <t>
        Operators should be able to to perform basic networking tasks
        such as disconnecting and reconnecting servers as needed to
        prevent long-term use of bad network routing. See
        <xref target="squit-command"/> (SQUIT) and
        <xref target="connect-command"/> (CONNECT).
      </t>
      <t>
        A more controversial power of operators is the ability to remove
        a user from the connected network by 'force', i.e. operators are
        able to close the connection between a client and server. The
        justification for this is delicate since its abuse is both
        destructive and annoying. For further details on this action,
        see <xref target="kill-command"/> (KILL).
      </t>
    </section>
  </section>
  <section title="Channels" anchor="channels">
    
    <t>
      A channel is a named group of one or more clients which will all
      receive messages addressed to that channel. The channel is created
      implicitly when the first client joins it, and the channel ceases
      to exist when the last client leaves is. While the channel exists,
      any client can reference the channel using the name of the
      channel.
    </t>
    <t>
      Channel names are strings (beginning with a '&amp;' or '#'
      character)., Apart from the requirement of the first character
      being either '&amp;' or '#'; the only restriction on a channel
      name is that it may not contain any spaces (' '), a control G (^G
      or ASCII 7), or a comma (',' which is used as a list item
      separator by the protocol).
    </t>
    <t>
      There are two types of channels defined by this protocol. One is a
      distributed channel which is known to all the servers that are
      connected to the network. These channels are marked by the first
      character being a '#'. The second type are server-specific
      channels, where the clients connected can only see and talk to
      other clients on the same server. These channels are distinguished
      by the first character being a '&amp;'.
    </t>
    <t>
      On top of these two types, there are various channel modes
      available to alter the characteristics of individual channels. See
      <xref target="mode-command"/> (MODE command) for more
      details on this.
    </t>
    <t>
      To create a new channel of become part of an existing channel, a
      user is required to JOIN the channel. If the channel doesn't exist
      prior to joining, the channel is created and the creating user
      becomes a channel operator. If the channel already exists, whether
      or not your request to JOIN that channel is honoured depends on
      the current modes of the channel. For example, if the channel is
      invite-only, (+i), then you may only join if invited. As part of
      the protocol, a user may be a part of several channels at once,
      but a limit may be imposed as to how many channels a user can be
      in at one time. This limit is specified the CHANLIMIT RPL_ISUPPORT
      token. See <xref target="feature-advertisement"/>
      (RPL_ISUPPORT) and <xref target="chanlimit"/> (CHANLIMIT)
      for more details on this.
    </t>
    <t>
      If the IRC network becomes disjoint because of a split between
      servers, the channel on either side is only composed of those
      clients which are connected to servers on the respective sides of
      the split, possibly ceasing to exist on one side of the split.
      When the split is healed, the connecting servers ensure the
      network state is consistent between them.
    </t>
    <section title="Channel Operators" anchor="channel-operators">
      
      <t>
        Channel operators (also referred to as a "chop" or
        "chanop") on a given channel are considered to 'own'
        that channel. In recognition of this status, channel operators
        are endowed with certain powers which enable them to keep
        control and some sort of sanity in their channel.
      </t>
      <t>
        As owners of a channel, channel operators are not required to
        have reasons for their actions, although if their actions are
        abusive, it may be reasonable to ask an IRC operator to
        intervene, or for the users to go elsewhere and form their own
        channel.
      </t>
      <t>
        The commands which may only be used by channel operators are:
      </t>
      <t><list style="symbols">
        <t>
          
            KICK - Eject a client from the channel
          
        </t>
        <t>
          
            MODE - Change the channel's modes
          
        </t>
        <t>
          
            INVITE - Invite a client to an invite-only channel (mode +i)
          
        </t>
        <t>
          
            TOPIC - Change the channel topic in a mode +t channel
          
        </t>
      </list></t>
      <t>
        A channel operator is identified by the '@' symbol next to their
        nickname whenever it is associated with a channel (ie replies to
        the NAMES, WHO and WHOIS commands).
      </t>
    </section>
  </section>
</section>
<section title="IRC Concepts" anchor="irc-concepts">
  
  <t>
    This section is devoted to describing the concepts behind the
    organisation of the IRC protocol and how the current implementations
    deliver different classes of messages.
  </t>
  <figure anchor="fig:smallsamplenet" align="center" title="Sample small IRC network."><artwork align="center">
                          1--\
                              A        D---4
                          2--/ \      /
                                B----C
                               /      \
                              3        E

   Servers: A, B, C, D, E         Clients: 1, 2, 3, 4
</artwork></figure>
  <t>
    
  </t>
  <section title="One-to-one communication" anchor="one-to-one-communication">
    
    <t>
      Communication on a one-to-one basis is usually only performed by
      clients, since most server-server traffic is not a result of
      servers talking only to each other.
    </t>
  </section>
</section>
<section title="Protocol Structure" anchor="protocol-structure">
  
  <section title="Overview" anchor="overview">
    
    <t>
      The protocol as described herein is for use with client to server
      connections.
    </t>
    <t>
      Various server to server protocols have been defined over the
      years, with TS6 and P10 (both based on the client to server
      protocol) among the most popular. However, with the fragmented
      nature of IRC server to server protocols and differences in server
      implementations, features and network designs, it is at this point
      impossible to define a single standard server to server protocol.
    </t>
    <section title="Character Codes" anchor="character-codes">
      
      <t>
        It is strongly RECOMMENDED that IRC servers and clients use the
        UTF-8 <xref target="RFC3629"/> character encoding,
        however implementations MAY use an alternative 8-bit character
        encoding for backwards compatibility or historical reasons.
      </t>
      <t>
        For historical reasons, the characters '{', '}', and '|' are
        considered to be the lower case equivalents of the characters
        '[', ']', and '', respectively. This is a critical issue when
        determining the equivalence of two nicknames.
      </t>
      <t>
        If the IRC server uses a character encoding other than UTF-8 or
        a casemapping other than the one specified in this section, it
        MUST include such information in the RPL_ISUPPORT numeric sent
        on completion of client registration, as set out in
        <xref target="rpl_isupport-parameters"/>.
      </t>
    </section>
  </section>
  <section title="Messages" anchor="messages">
    
    <t>
      Servers and clients send each other messages which may or may not
      generate a reply; client to server communication is essentially
      asynchronous in nature.
    </t>
    <t>
      Each IRC message may consist of up to four main parts: tags
      (optional), the prefix (optional), the command, and the command
      parameters (of which there may be up to 15).
    </t>
    <section title="Tags" anchor="tags">
      
      <t>
        Tags are additional and optional metadata included with relevant
        messages.
      </t>
      <t>
        Every message tag is enabled by a capacity (as outlined in
        <xref target="capability-negotiation"/>). One capability
        may enable several tags is those tags are intended to be used
        together.
      </t>
      <t>
        Each tag may have its own rules about how it can be used: from
        client to server only, from server to client only, or in both
        directions.
      </t>
      <t>
        The server MUST NOT add a tag to a message if the client has not
        requested the capability which enables the tag. The server MUST
        NOT add a tag to a message before replying to a client's CAP REQ
        with CAP ACK. If a client requests a capability which enables
        one or more message tags, that client MUST be able to parse the
        message tags syntax.
      </t>
      <t>
        Similarly, the client MUST NOT add a tag to messages before the
        server replies to the client's CAP REQ with CAP ACK. If the
        server accepts the capability request with CAP ACK, the server
        MUST be able to parse the message tags syntax.
      </t>
      <t>
        Both clients and servers MAY parse supplied tags without any
        capabilities being enabled on the connection. They SHOULD ignore
        the tags of capabilities which are not enabled.
      </t>
      <t>
        The rules for naming and registering tags are detailed in
        <xref target="message-tags"/>
      </t>
    </section>
    <section title="Message Prefix" anchor="message-prefix">
      
      <t>
        The prefix is used by servers to indicate the true origin of a
        message. If the prefix is missing from the message, it is
        assumed to have originated from the connection from which it was
        received.
      </t>
      <t>
        Clients SHOULD NOT use a prefix when sending a message from
        themselves; if they use a prefix, the only valid prefix is the
        registered nickname associated with the client. If the source
        identified by the prefix cannot be found in the server's
        internal database, or if the source is registered from a
        different link than from which the message arrived, the server
        MUST ignore the message silently.
      </t>
    </section>
    <section title="Command" anchor="command">
      
      <t>
        The command must either be a valid IRC command or a three-digit
        number represented as text.
      </t>
    </section>
  </section>
  <section title="Wire Format" anchor="wire-format">
    
    <t>
      The protocol messages are extracted from a contiguous stream of
      octets. A pair of characters, CR (0x13) and LF (0x10), act as
      message separators. Empty messages are silently ignored, which
      permits use of the sequence CR-LF between messages.
    </t>
    <t>
      The tags, prefix, command, and all parameters are separated by one
      (or more) ASCII space character(s) (0x20).
    </t>
    <t>
      The presense of tags is indicated with a single leading character
      ('@', 0x40), which MUST be the first character of the message
      itself. There MUST NOT be any whitespace between this leading
      character and the list of tags.
    </t>
    <t>
      The presence of a prefix is indicated with a single leading colon
      character (':', 0x3b). If there are no tags it MUST be the first
      character of the message itself. There MUST NOT be any whitespace
      between this leading character and the prefix
    </t>
    <t>
      IRC messages shall not exceed 1024 bytes in length, counting all
      characters including the trailing CR-LF. There are a maximum of
      512 bytes allocated for message tags, including the leading '@'
      and trailing space. There are 510 bytes maximum allowed for the
      command and its parameters. There is no provision for continuation
      message lines.
    </t>
    <section title="Wire format in 'pseudo' ABNF" anchor="wire-format-in-pseudo-abnf">
      
      <t>
        The extracted message is parsed into the components
        <spanx style="verb">tags</spanx>, <spanx style="verb">prefix</spanx>,
        <spanx style="verb">command</spanx>, and a list of parameters
        (<spanx style="verb">params</spanx>).
      </t>
      <t>
        The ABNF representation for this is:
      </t>
      <figure><artwork>
  message    =  ["@" tags SPACE ] [ ":" prefix SPACE ] command
                [ params ] crlf
  tags       =  tag *[";" tag]
  tag        =  key ["=" value]
  key        =  [ &lt;vendor&gt; '/' ] &lt;sequence of letters, digits,
                hyphens (`-`)&gt;
  value      =  &lt;sequence of any characters except NUL, BELL,
                CR, LF, semicolon (`;`) and SPACE&gt;
  vendor     =  hostname
  prefix     =  servername / ( nickname [ [ "!" user ] "@" host ] )
  command    =  1*letter / 3digit
  params     =  *13( SPACE middle ) [ SPACE ":" trailing ]
             =/ 14( SPACE middle ) [ SPACE [ ":" ] trailing ]
      
  nospcrlfcl =  %x01-09 / %x0B-0C / %x0E-1F / %x21-39 / %x3B-FF
                  ; any octet except NUL, CR, LF, " " and ":"
  middle     =  nospcrlfcl *( ":" / nospcrlfcl )
  trailing   =  *( ":" / " " / nospcrlfcl )
  
  SPACE      =  %x20        ; space character
  crlf       =  %x0D %x0A   ; "carriage return" "linefeed"
</artwork></figure>
      <t>
        NOTES:
      </t>
      <t><list style="numbers">
        <t>
          
            After extracting the parameter list, all parameters are
            equal, whether matched by &lt;middle&gt; or
            &lt;trailing&gt;. &lt;trailing&gt; is just a syntactic trick
            to allow ASCII SPACE characters within a parameter.
          
        </t>
        <t>
          
            The NUL (%x00) character is not special in message framing,
            but as it would cause extra complexities in traditional C
            string handling, it is not allowed within messages.
          
        </t>
        <t>
          
            The last parameter may be an empty string.
          
        </t>
        <t>
          
            Use of the extended prefix (['!' &lt;user&gt; ] ['@'
            &lt;host&gt; ]) is only intended for server to client
            messages in order to provide clients with more useful
            information about who a message is from without the need for
            additional queries.
          
        </t>
      </list></t>
      <t>
        Most protocol messages specify additional semantics and syntax
        for the extracted parameter strings dictated by their position
        in the list. For example, many server commands will assume that
        the first parameter after the command is a list of targets.
      </t>
    </section>
  </section>
</section>
<section title="Connection Registration" anchor="connection-registration">
  
  <t>
    Immediately upon establishing a connection the client must attempt
    registration without waiting for any banner message from the server.
  </t>
  <t>
    Until registration is complete, only a limited subset of commands
    may be accepted by the server.
  </t>
  <t>
    The recommended order of commands during registration is as follows:
  </t>
  <t><list style="numbers">
    <t>
      
        PASS
      
    </t>
    <t>
      
        CAP
      
    </t>
    <t>
      
        NICK
      
    </t>
    <t>
      
        USER
      
    </t>
  </list></t>
  <t>
    The PASS command (see <xref target="password-command"/>) is
    not required for the connection to be registered, but if included it
    MUST precede the latter of the NICK and USER commands.
  </t>
  <t>
    If the server supports capability negotiation, the CAP command (see
    <xref target="cap-command"/>) suspends the registration
    process and immediately starts the capability negotiation (see
    <xref target="capability-negotiation"/>) process.
  </t>
  <t>
    The NICK and USER commands (see <xref target="nick-command"/>
    and <xref target="user-command"/>, respectively) are used to
    identify the user's nickname, username and "real name".
    Unless the registration is suspended by a CAP negotiation, these
    commands will end the registration process.
  </t>
  <t>
    Upon successful completion of the registration process, the server
    MUST send the RPL_WELCOME (001) and RPL_ISUPPORT (005) numerics. The
    server SHOULD also send the Message of the Day (MOTD), if one
    exists, and MAY send other numerics.
  </t>
  <section title="Feature Advertisement" anchor="feature-advertisement">
    
    <t>
      IRC server and networks implement many different IRC features,
      limits, and protocol options that clients should be aware of. The
      RPL_ISUPPORT (005) numeric is designed to advertise these features
      to clients on connection registration, providing a simple way for
      clients to change their behaviour according to what is implemented
      on the server.
    </t>
    <t>
      Once client registration is complete, the server MUST send at
      least one RPL_ISUPPORT numeric to the client. The server MAY send
      more than one RPL_ISUPPORT numeric and it is RECOMMENDED that
      consecutive RPL_ISUPPORT numerics are sent adjacent to each other.
    </t>
    <t>
      Clients SHOULD NOT assume a server supports a feature unless it
      has been advertised in RPL_ISUPPORT. For RPL_ISUPPORT parameters
      which specify a 'default' value, clients SHOULD assume the default
      value for these parameters until the server advertises these
      parameters itself. This is generally done for compatibility
      reasons with older versions of the IRC protocol that do not
      require the RPL_ISUPPORT numeric.
    </t>
    <t>
      The ABNF representation for this is:
    </t>
    <figure><artwork>
  isupport   =  [ ":" servername SPACE ] "005" SPACE nick SPACE
                1*13( token SPACE ) ":are supported by this server"

  token      =  *1"-" parameter / parameter *1( "=" value )
  parameter  =  1*20 letter
  value      =  * letpun
  letter     =  ALPHA / DIGIT
  punct      =  %d33-47 / %d58-64 / %d91-96 / %d123-126
  letpun     =  letter / punct

  SPACE      =  %x20        ; space character
</artwork></figure>
    <t>
      &lt;servername&gt; and &lt;nick&gt; are as specified above.
    </t>
    <t>
      As with other local numerics, when RPL_ISUPPORT is delivered
      remotely, it MUST be converted into a <spanx style="verb">105</spanx>
      numeric before delivery to the client.
    </t>
    <t>
      A token is of the form <spanx style="verb">-PARAMETER</spanx>,
      <spanx style="verb">PARAMETER</spanx>, or
      <spanx style="verb">PARAMETER=VALUE</spanx>. A server MAY send an empty
      value feild and a parameter MAY have a default value. A server
      MUST send the parameter as upper-case text. Unless otherwise
      stated, when a parameter contains a value, the value MUST be
      treated as being case sensitive. The value MAY contain multiple
      fields, if this is the case the fields MUST be delimited with a
      comma character (<spanx style="verb">,</spanx>).
    </t>
    <t>
      It is possible for the status of features previously advertised to
      clients can change. When this happens, a server SHOULD reissue the
      RPL_ISUPPORT numeric with the relevant parameters that have
      changed. If a feature becomes unavailable, the server MUST prefix
      the parameter with the dash character ('-') when issuing the
      updated RPL_ISUPPORT.
    </t>
    <t>
      As the maximum number of parameters to any reply is 15, the
      maximum number of RPL_ISUPPORT tokens that can be advertised is
      13. To counter this, a server MAY issue multiple RPL_ISUPPORT
      numerics. A server MUST issue the RPL_ISUPPORT numeric after
      client registration has completed. It also MUST be issued after
      the RPL_WELCOME (001) numeric and MUST be issued before further
      commands from the client are processed.
    </t>
    <t>
      A list of known RPL_ISUPPORT parameters is available in
      <xref target="rpl_isupport-parameters"/>.
    </t>
  </section>
  <section title="Capability Negotiation" anchor="capability-negotiation">
    
    <t>
      Over the years, various extensions to the IRC protocol have been
      made by server programmers. Often, these extensions are intended
      to conserve bandwidth, close loopholes left by the original
      protocol specification, or add new features for users or for the
      server administrators. Most of these changes are
      backwards-compatible with the base protocol specifications: A
      command may be added, a reply may be extended to contain more
      parameters, etc. However, there are extensions which may be
      designed to change protocol behaviour in a backwards-incompatible
      way.
    </t>
    <t>
      Capability Negotiation is a mechanism for the negotiation of
      protocol extensions, known as
      <spanx style="strong">capabilities</spanx>, that is
      backwards-compatible with all existing IRC clients and servers
      (including those using earlier versions of the IRC protocol).
      While all servers implementing IRCv3 support capability
      negotiation, it is important for clients implementing IRCv3 to
      support servers using earlier protocol versions, and for servers
      implementing IRCv3 connecting to clients without support.
    </t>
    <t>
      Any server not implementing capability negotiation will still
      interoperate with clients that do implement it; similarly, clients
      that do not implement capability negotiation may successfully
      communicate with a server that does implement it.
    </t>
    <t>
      IRC is an asynchronous protocol, which means that clients may
      issue additional IRC commands while previous commands are being
      processed. Additionally, there is no guarantee of a specific kind
      of banner being issues upon connection. Some servers also do not
      complain about unknown commands during registration, which means
      that a client cannot reliably do passive implementation discovery
      at registration time.
    </t>
    <t>
      The solution to these problems is to allow for active capability
      negotiation, and to extend the registration process with this
      negotiation. If the server support capability negotiation, the
      registration process will be suspended until negotiation is
      completed. If the server does not support this feature, then
      registration will complete immediately and the client will not use
      any capabilities.
    </t>
    <t>
      Capability negotiation is started by the client issuing a
      <spanx style="verb">CAP LS</spanx> command. Negotiation is then performed
      with the <spanx style="verb">CAP REQ</spanx>, <spanx style="verb">CAP ACK</spanx>,
      and <spanx style="verb">CAP NAK</spanx> commands, and is ended with the
      <spanx style="verb">CAP END</spanx> command (See
      <xref target="cap-command"/>).
    </t>
    <t>
      Once capability negotiation has ended, the registration process
      shall resume.
    </t>
  </section>
</section>
<section title="Client commands" anchor="client-commands">
  
  <section title="Connection commands" anchor="connection-commands">
    
    <section title="Password command" anchor="password-command">
      
      <figure><artwork>
     Command: PASS
  Parameters: &lt;password&gt;
</artwork></figure>
      <t>
        The PASS command is used to set a 'connection password'. The
        password can and must be set before any attempt to register the
        connection is made. This requires that clients send a PASS
        command before sending the CAP/NICK/USER combination.
      </t>
      <t>
        The password supplied must match the one contained in I lines.
        It is possible to send multiple PASS commands before registering
        but only the last one sent is used for verification and it may
        not be changed once registered.
      </t>
      <t>
        Numeric replies:
      </t>
      <figure><artwork>
           ERR_NEEDMOREPARAMS              ERR_ALREADYREGISTRED
</artwork></figure>
      <t>
        Example:
      </t>
      <figure><artwork>
  PASS secretpasswordhere
</artwork></figure>
    </section>
    <section title="Nick command" anchor="nick-command">
      
      <figure><artwork>
     Command: NICK
  Parameters: &lt;nickname&gt;
</artwork></figure>
      <t>
        The NICK command is used to give the client a nickname or change
        the previous one.
      </t>
      <t>
        If the server receives a NICK command from a client with a
        <spanx style="verb">&lt;nickname&gt;</spanx> which is already in use on
        the network, it may issue an ERR_NICKCOLLISION to the client and
        ignore the NICK command.
      </t>
      <t>
        Numeric Replies:
      </t>
      <figure><artwork>
           ERR_NONICKNAMEGIVEN             ERR_ERRONEUSNICKNAME
           ERR_NICKNAMEINUSE               ERR_NICKCOLLISION
</artwork></figure>
      <t>
        Example:
      </t>
      <figure><artwork>
  NICK Wiz                  ; Introducing the new nick "Wiz".

  :WiZ NICK Kilroy          ; WiZ changed his nickname to Kilroy.
</artwork></figure>
    </section>
    <section title="User command" anchor="user-command">
      
      <figure><artwork>
     Command: USER
  Parameters: &lt;username&gt; &lt;hostname&gt; &lt;servername&gt; &lt;realname&gt;
</artwork></figure>
      <t>
        The USER command is used at the beginning of a connection to
        specify the username, hostname, servername and realname of a new
        user.
      </t>
      <t>
        It must be noted that <spanx style="verb">&lt;realname&gt;</spanx> must
        be the last parameter, because it may contain space characters
        and must be prefixed with a colon (<spanx style="verb">:</spanx>) to make
        sure this is recognised as such.
      </t>
      <t>
        Since it is easy for a client to lie about its username by
        relying solely on the USER command, the use of an "Identity
        Server" is recommended. If the host which a user connects
        from has such a server enabled, the username is set to that as
        in the reply from the "Identity Server". If the host
        does not have such a server enabled, the username is set to the
        value of the <spanx style="verb">&lt;username&gt;</spanx> parameter,
        prefixed by a tilde (<spanx style="verb">~</spanx>) to show that this
        value is user-set.
      </t>
      <t>
        Numeric Replies:
      </t>
      <figure><artwork>
             ERR_NEEDMOREPARAMS              ERR_ALREADYREGISTRED
</artwork></figure>
      <t>
        Examples:
      </t>
      <figure><artwork>
  USER guest tolmoon tolsun :Ronnie Reagan
                              ; No ident server
                              ; User gets registered with username
                              "~guest" and real name "Ronnie Reagan"

  USER guest tolmoon tolsun :Ronnie Reagan
                              ; Ident server gets contacted and
                              returns the name "danp"
                              ; User gets registered with username
                              "danp" and real name "Ronnie Reagan"
</artwork></figure>
    </section>
    <section title="CAP command" anchor="cap-command">
      
      <t>
        The CAP command takes a single required subcommand, optionally
        followed by a single parameter of space-separated capability
        identifiers. Each capability in the list MAY be preceded by a
        capability modifier (see
        <xref target="capability-modifiers"/>).
      </t>
      <t>
        The subcommands for CAP are: LS, LIST, REQ, ACK, NAK, and END
        (see <xref target="cap-subcommands"/>).
      </t>
      <t>
        The LS, LIST, REQ, ACK and NAK subcommands MAY be followed by a
        single parameter containing a space-separated list of
        capabilities.
      </t>
      <t>
        If more than one capability is named, the designated sentinal
        (<spanx style="verb">:</spanx>) for a multi-parameter argument MUST be
        present.
      </t>
      <t>
        If a client sends a subcommand which is not in the list above or
        otherwise issues an invalid command, then ERR_INVALIDCAPCMD
        (numeric 410) MUST be sent. The first parameter after the client
        identifier (usually nickname) MUST be the command name; the
        second parameter SHOULD be a human-readable description of the
        error.
      </t>
      <t>
        Replies from the server must contain the client identifier name
        or an asterisk (<spanx style="verb">*</spanx>) if one is not yet
        available.
      </t>
      <section title="Capability Modifiers" anchor="capability-modifiers">
        
        <t>
          There are three capability modifiers specified by this
          document. If a capability modifier is to be used, it MUST
          directly proceede the capability identifier.
        </t>
        <t>
          The capability modifiers are:
        </t>
        <t><list style="symbols">
          <t>
            
              "-" modifier (disable): this modifier indicates
              that the capability is being disabled.
            
          </t>
          <t>
            
              "~" modifier (ack): this modifier indicates the
              client must acknowledge the capability using an ACK
              subcommand.
            
          </t>
          <t>
            
              "=" modifier (sticky): this modifier indicates
              that the specified capability may not be disabled.
            
          </t>
        </list></t>
      </section>
    </section>
    <section title="CAP subcommands" anchor="cap-subcommands">
      
      <section title="CAP LS subcommand" anchor="cap-ls-subcommand">
        
        <t>
          The LS subcommand is used to list the capabilities supported
          by the server. The client should send an LS subcommand with no
          other arguments to solicit a list of all arguments.
        </t>
        <t>
          If a client issues an LS subcommand during client
          registration, registration must be suspended until an END
          subcommand is received.
        </t>
        <t>
          Example:
        </t>
        <figure><artwork>
  Client: CAP LS
  Server: CAP * LS :multi-prefix sasl
</artwork></figure>
      </section>
      <section title="CAP LIST subcommand" anchor="cap-list-subcommand">
        
        <t>
          The LIST subcommand is used to list the capabilities
          associated with the active connection. The client should send
          a LIST subcommand with no other arguments to solicit a list of
          active capabilities.
        </t>
        <t>
          If no other capabilities are active, an empty parameter must
          be sent.
        </t>
        <t>
          Example:
        </t>
        <figure><artwork>
  Client: CAP LIST
  Server: CAP * LIST :multi-prefix
</artwork></figure>
      </section>
      <section title="CAP REQ subcommand" anchor="cap-req-subcommand">
        
        <t>
          The REQ subcommand is used to request a change in capabilities
          associated with the active connection. Its sole parameter must
          be a list of space-separated capability identifiers. Each
          capability identifier must be prefixed with a dash
          (<spanx style="verb">-</spanx>) to designate that the capability should
          be disabled.
        </t>
        <t>
          The capability identifier set must be accepted as a whole, or
          rejected entirely.
        </t>
        <t>
          If a client issues a REQ subcommand, registration must be
          suspended until an END subcommand is received.
        </t>
        <t>
          Example:
        </t>
        <figure><artwork>
  Client: CAP REQ :multi-prefix sasl
  Server: CAP * ACK :multi-prefix sasl
</artwork></figure>
      </section>
      <section title="CAP ACK subcommand" anchor="cap-ack-subcommand">
        
        <t>
          The ACK subcommand has two uses:
        </t>
        <t><list style="symbols">
          <t>
            
              The server sends it to acknowledge a REQ subcommand.
            
          </t>
          <t>
            
              The client sends it to acknowledge capabilities which
              require client-side acknowledgement.
            
          </t>
        </list></t>
        <t>
          If an ACK reply originating from the server is spread across
          multiple lines, a client MUST NOT change capabilities until
          the last ACK of the set is received. Equally, a server MUST
          NOT change the capabilities of the client until the last ACK
          of the set has been sent.
        </t>
        <t>
          In the first usage, acknowledging a REQ subcommand, the ACK
          subcommand has a single parameter consisting of a
          space-separated list of capability names, which may optionally
          be preceded with one or more modifiers (see
          <xref target="capability-modifiers"/> for details of
          capability modifiers).
        </t>
        <t>
          The third usage is when, in the preceding case, some
          capability names may have been preceded with the ack modifier.
          ACK in this case is used to full enable or disable the
          capability. Clients MUST NOT issue an ACK subcommand for any
          capability not marked with the ack modifier in a
          server-generated ACK subcommand.
        </t>
      </section>
      <section title="CAP NAK subcommand" anchor="cap-nak-subcommand">
        
        <t>
          The NAK subcommand designates that the requested capability
          change was rejected. The server MUST NOT make any change to
          any capabilities if it replies with a NAK subcommand.
        </t>
        <t>
          The argument of the NAK subcommand MUST consist of at least
          the first 100 characters of the capability list in the REQ
          subcommand which triggered the NAK.
        </t>
      </section>
      <section title="CAP END subcommand" anchor="cap-end-subcommand">
        
        <t>
          The END subcommand signals to the server that capability
          negotiation is complete and requests that the server continue
          with client registration. If the client is already registered,
          this command MUST be ignored by the server.
        </t>
        <t>
          Clients that support capabilities but do not wish to enter
          negotiation SHOULD send CAP END upon connection to the server.
        </t>
      </section>
    </section>
  </section>
  <section title="Server Queries and Commands" anchor="server-queries-and-commands">
    
    <t>
      The server query group of commands has been designed to return
      information about any server which is connected to the networks.
      All servers connected must respond to these queries and respond
      correctly. Any invalid response (or lack thereof) must be
      considered a sign of a broken server and it must be
      disconnected/disabled as soon as possible until the situation is
      remedied.
    </t>
    <t>
      In these queries, where a parameter appears as
      <spanx style="verb">&lt;server&gt;</spanx>, it usually means it can be a
      nickname or a server or a wildcard name of some sort. For each
      parameter, however, only one query and set or replies is to be
      generated.
    </t>
    <section title="VERSION command" anchor="version-command">
      
      <figure><artwork>
     Command: VERSION
  Parameters: [&lt;server&gt;]
</artwork></figure>
      <t>
        The VERSION command is used to query the version of the server
        software, and to request the server's ISUPPORT tokens. An
        optional parameter <spanx style="verb">&lt;server&gt;</spanx> is used to
        query the version of the given server instead of the server the
        client is directly connected to.
      </t>
      <t>
        Numeric Replies:
      </t>
      <figure><artwork>
           ERR_NOSUCHSERVER                RPL_VERSION
</artwork></figure>
      <t>
        Examples:
      </t>
      <figure><artwork>
  :Wiz VERSION *.se               ; message from Wiz to check the
                                  version of a server matching "*.se"

  VERSION tolsun.oulu.fi          ; check the version of server
                                  "tolsun.oulu.fi".
</artwork></figure>
    </section>
    <section title="CONNECT command" anchor="connect-command">
      
      <figure><artwork>
     Command: CONNECT
  Parameters: &lt;target server&gt; [&lt;port&gt; [&lt;remote server&gt;]]
</artwork></figure>
      <t>
        The CONNECT command forces a server to try to establish a new
        connection to another server. CONNECT is a privileged command
        and is available only to IRC Operators. If a remote server is
        given, the connection is attempted by that remote server to
        <spanx style="verb">&lt;target server&gt;</spanx> using
        <spanx style="verb">&lt;port&gt;</spanx>.
      </t>
      <t>
        Numeric Replies:
      </t>
      <figure><artwork>
           ERR_NOSUCHSERVER                ERR_NEEDMOREPARAMS
           ERR_NOPRIVILEGES
</artwork></figure>
      <t>
        Examples:
      </t>
      <figure><artwork>
  CONNECT tolsun.oulu.fi
  ; Attempt to connect the current server to tololsun.oulu.fi

  CONNECT  eff.org 12765 csd.bu.edu
  ; Attempt to connect csu.bu.edu to eff.org on port 12765
</artwork></figure>
    </section>
    <section title="TIME command" anchor="time-command">
      
      <figure><artwork>
     Command: TIME
  Parameters: [&lt;server&gt;]
</artwork></figure>
      <t>
        The TIME command is used to query local time from the specified
        server. If the server parameter is not given, the server
        handling the command must reply to the query.
      </t>
      <t>
        Numeric Replies:
      </t>
      <figure><artwork>
           ERR_NOSUCHSERVER                RPL_TIME
</artwork></figure>
      <t>
        Examples:
      </t>
      <figure><artwork>
  TIME tolsun.oulu.fi             ; check the time on the server
                                  "tolson.oulu.fi"

  Angel TIME *.au                 ; user angel checking the time on a
                                  server matching "*.au"
</artwork></figure>
    </section>
    <section title="STATS command" anchor="stats-command">
      
      <figure><artwork>
     Command: STATS
  Parameters: [&lt;query&gt; [&lt;server&gt;]]
</artwork></figure>
      <t>
        The STATS command is used to query statistics of a certain
        server. If the <spanx style="verb">&lt;server&gt;</spanx> parameter is
        ommitted, only the end of stats reply is sent back. The
        implemented of this command is highly dependent on the server
        which replies, although the server must be able to supply
        information as described by the queries below (or similar).
      </t>
      <t>
        A query may be given by any single letter which is only checked
        by the destination server and is otherwise passed on by
        intermediate servers, ignored and unaltered.
      </t>
      <t>
        The following queries are those found in current IRC
        implementations and provide a large portion of the setup
        information for that server. All servers should be able to
        supply a valid reply to a STATS query which is consistent with
        the reply formats currently used and the purpose of the query.
      </t>
      <t>
        The currently supported queries are:
      </t>
      <figure><artwork>
    c - returns a list of servers which the server may connect
        to or allow connections from;
    h - returns a list of servers which are either forced to be
        treated as leaves or allowed to act as hubs;
    i - returns a list of hosts which the server allows a client
        to connect from;
    k - returns a list of banned username/hostname combinations
        for that server;
    l - returns a list of the server's connections, showing how
        long each connection has been established and the traffic
        over that connection in bytes and messages for each
        direction;
    m - returns a list of commands supported by the server and
        the usage count for each if the usage count is non zero;
    o - returns a list of hosts from which normal clients may
        become operators;
    y - show Y (Class) lines from server's configuration file;
    u - returns a string showing how long the server has been up.
</artwork></figure>
      <t>
        Numeric Replies:
      </t>
      <figure><artwork>
        ERR_NOSUCHSERVER
        RPL_STATSCLINE                  RPL_STATSNLINE
        RPL_STATSILINE                  RPL_STATSKLINE
        RPL_STATSQLINE                  RPL_STATSLLINE
        RPL_STATSLINKINFO               RPL_STATSUPTIME
        RPL_STATSCOMMANDS               RPL_STATSOLINE
        RPL_STATSHLINE                  RPL_ENDOFSTATS
</artwork></figure>
      <t>
        Examples:
      </t>
      <figure><artwork>
  STATS m                         ; check the command usage for the
                                  server you are connected to

  :Wiz STATS c eff.org            ; request by WiZ for C/N line
                                  information from server eff.org
</artwork></figure>
    </section>
  </section>
</section>
<section title="Temporary headers so references to unwritten sections work" anchor="temporary-headers-so-references-to-unwritten-sections-work">
  
  <section title="Kill Command" anchor="kill-command">
    
    <t>
    </t>
  </section>
  <section title="Mode Command" anchor="mode-command">
    
    <t>
    </t>
  </section>
  <section title="Channel Prefix" anchor="channel-prefix">
    
    <t>
    </t>
  </section>
  <section title="Feature Advertisement Appendix" anchor="feature-advertisement-appendix">
    
    <t>
    </t>
  </section>
  <section title="Notice Command" anchor="notice-command">
    
    <t>
    </t>
  </section>
  <section title="Privmsg Command" anchor="privmsg-command">
    
    <t>
    </t>
  </section>
  <section title="User Command" anchor="user-command-1">
    
    <t>
    </t>
  </section>
  <section title="Squit Command" anchor="squit-command">
    
    <t>
    </t>
  </section>
  <section title="Message Tags" anchor="message-tags">
    
    <t>
    </t>
  </section>
  <section title="Channel Bans and Exceptions" anchor="channel-bans-and-exceptions">
    
    <t>
    </t>
  </section>
  <section title="Channel Invitation" anchor="channel-invitation">
    
    <t>
    </t>
  </section>
  <section title="Sending Messages" anchor="sending-messages">
    
    <t>
    </t>
  </section>
  <section title="Topic Command" anchor="topic-command">
    
    <t>
    </t>
  </section>
  <section title="ISON Command" anchor="ison-command">
    
    <t>
    </t>
  </section>
</section>
<section title="Acknowledgements" anchor="acknowledgements">
  
  <t>
    Parts of this document came from the "IRC RPL_ISUPPORT Numeric
    Definition" Internet Draft authored by L. Hardy, E. Brocklesby,
    and K. Mitchell. Parts of this document came from the "IRC
    Client Capabilities Extension" Internet Draft authored by K.
    Mitchell, P. Lorier, L. Hardy, and P. Kucharski.
  </t>
  <t>
    Thanks to all the IRC software and document authors throughout the
    years.
  </t>
</section>

